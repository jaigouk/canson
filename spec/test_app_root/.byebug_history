exit
resexit
Iodine::Protocol.public_methods
Iodine::Rack.new.public_methods
Iodine::Rack.public_methods
Iodine::Rack
Iodine.public_methods
exit
@on_message.class.instance_exec(data, &(@on_message.call))
@on_message
data
n
exit
routes[:on_open]['websocket_method'].response_handler
routes[:on_open]['websocket_method']
routes[:on_open].response_handler
routes[:on_open]
routes[:on_message][nickname].on_open = routes[:on_open].response_handler
routes[:on_message][nickname] ||= Canson::Websocket.new(env)
routes[:on_message][nickname]
exit
routes[:on_message][nickname]
routes[:on_message]
routes[:on_message][nickname] ||= Canson::Websocket.new(env)
nickname
exit
routes[:ws][:on_open]
routes[:ws][:on_message].class
routes[:ws]
routes[:ws][:on_message]
routes[:ws][:on_message][nickname]
nickname = env['PATH_INFO'][1..-1].force_encoding 'UTF-8'
exit
env['rack.input'].read
env
exit
env
n
env
n
env['rack.input'].read
env['rack.input']
env['PATH_INFO'] == '/'
env['HTTP_UPGRADE']
env['REQUEST_METHOD']
m = env['REQUEST_METHOD'].tr('/', '').downcase.to_sym
env
exit
env['upgrade.websocket']
env['HTTP_VERSION'.freeze] =~ /websocket/i
env['HTTP_UPGRADE'.freeze] =~ /websocket/i
nv['HTTP_UPGRADE'.freeze] =~ /websocket/i
env['HTTP_UPGRADE']
env
exit
result.values.include? nil
result.values
result
exit
result
exit
result
exit
req.params.empty?
req.params
req = Rack::Request.new(env)
param
re
exit
req.body.read
req.params
req = Rack::Request.new(env)
env
get_param(env)
param
exit
req.params
req
req = Rack::Request.new(env)
Rack::Request.new(env)
env['PATH_INFO']
target = routes[m][env['PATH_INFO']]
env['rack.input'].read
env
exit
env
env['rack.input'].read
env['rack.input'].to_json
env['rack.input'].read
env['rack.input'].gets
env['rack.input'].public_methods
env['rack.input'].read
env['rack.input']
env
env['rack.input'].gets
exit
req.body.read
req.body
JSON.parse( req.body.read )
req
env
param.empty?
req.params.map { |k, _v| k }.first 
req.params.map { |k, _v| k }.first |
req.params
req.body.read
req.body
req.input
req
exit
req.params
req.body.read
req = Rack::Request.new(env)
env.body
env
param
exit
param.empty?
param
req.body.read
req.params
req
param
exit
req.body.read
param = req.params.map { |k, _v| k }.first
req = get_req(env)
env
parse_body(get_req(env))
call_result(env, target)
target
exit
params
exit
parse_body(req)
req
target.call
